import User from "../models/User.js";
import UserProgress from "../models/UserProgress.js";
import JournalEntry from "../models/JournalEntry.js";
import bcrypt from "bcryptjs";
import generateToken from "../utils/createToken.js";
import { normalizeNames, formatDateAndMonth } from "../utils/helpers.js";
import mongoose from "mongoose";

// ---------- Auth Controllers ----------

// Registering a new user
export const registerUser = async (req, res) => {
  try {
    const { firstName, lastName, username, email, password, linkedIn } = req.body;

    // Normalize first and last names
    const formattedFirstName = normalizeNames(firstName);
    const formattedLastName = normalizeNames(lastName);

    // Hash the user password using bcrypt before saving
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);
    const newUser = new User({
      firstName: formattedFirstName,
      lastName: formattedLastName,
      username,
      email,
      password: hashedPassword,
      linkedIn
    });

    try {
      const savedUser = await newUser.save();
      generateToken(res, savedUser._id);
      res.status(201).json({
        message: "User registered successfully",
        user: {
          id: savedUser._id,
          firstName: savedUser.firstName,
          lastName: savedUser.lastName,
          username: savedUser.username,
          email: savedUser.email,
          linkedIn: savedUser.linkedIn
        }
      });
    } catch (error) {
      res.status(400).json({
        message: "User registration failed. Please check your details.",
        error: error.message
      });
    }
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

// Not fully implemented yet
export const loginUser = async (req, res) => {
  return res.send({ message: "Hello there - authorisation success!" });
};

export const getUserInfo = async (req, res) => {
  const id = req.user._id;
  // Check if id is valid
  if (!mongoose.isValidObjectId(id)) {
    return res.status(400).json({ message: "Invalid user ID" });
  }
  const user = await User.findById(id);
  if (user === null) {
    return res.status(404).send(`User with id ${id} not found`);
  }
  return res.status(200).send(`Succesful! ${user}`);
};

// Logging out a user
export const logoutUser = (req, res) => {
  try {
    res.cookie("jwt", "", {
      httpOnly: true,
      expires: new Date(0), // Set the cookie to expire immediately
      secure: process.env.NODE_ENV === "production",
      sameSite: "strict"
    });
    return res.status(200).json({ message: "Logged out successfully" });
  } catch (error) {
    return res.status(500).json({ message: "Server error", error: error.message });
  }
};

// Updating a user's profile
export const updateUserProfile = async (req, res) => {
  try {
    const user = await User.findById(req.user._id);

    if (user) {
      user.firstName = normalizeNames(req.body.firstName) || user.firstName;
      user.lastName = normalizeNames(req.body.lastName) || user.lastName;
      user.username = req.body.username || user.username;
      user.email = req.body.email || user.email;
      user.linkedIn = req.body.linkedIn || user.linkedIn;

      // Updating password
      if (req.body.password) {
        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(req.body.password, salt);
        user.password = hashedPassword;
      }

      const updatedUser = await user.save();

      res.json({
        _id: updatedUser._id,
        firstName: updatedUser.firstName,
        lastName: updatedUser.lastName,
        username: updatedUser.username,
        email: updatedUser.email,
        linkedIn: updatedUser.linkedIn
      });
    } else {
      res.status(404);
      throw new Error("User not found");
    }
  } catch (error) {
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

// ---------- User Management Controllers ----------

// Deleting a user's account
export const deleteUser = async (req, res) => {
  const id = req.user._id;
  // Check if id is valid
  if (!mongoose.isValidObjectId(id)) {
    return res.status(400).json({ message: "Invalid user ID" });
  }
  const user = await User.deleteOne({ _id: id });
  if (user === null) {
    return res.status(404).send(`User with id ${id} not found`);
  }
  return res.status(200).send(`${user} Sucessfully delelted`);
};

// Adding a user (for testing purposes)
export const addUser = async (req, res) => {
  const user = await User.create({
    firstName: "Alison",
    lastName: "Davidson",
    username: "ali123",
    email: "alison@gmail.com",
    password: "bearLingoI$C00l",
    streak: {
      lastActive: "2023-01-15T10:30:00Z",
      current: 10,
      longest: 10
    }
  });
  console.log("Created user:", user);
  return res.status(201).send(`${user} created!`);
};

// Getting all users
export const getAllUsers = async (_, res) => {
  try {
    const users = await User.find({});
    return res.status(200).json(users);
  } catch (error) {
    return res.status(500).json({ message: "Server error", error: error.message });
  }
};

// ---------- Progress & Tracking Controllers ----------

// Getting a user's completed levels
export const getCompletedLevels = async (req, res) => {
  const id = req.user._id;
  // Check if id is valid
  if (!mongoose.isValidObjectId(id)) {
    return res.status(400).json({ message: "Invalid user ID" });
  }
  const user = await User.findOne({ _id: id });
  if (user === null) {
    return res.status(404).send(`User with id ${id} not found`);
  }
  const progress = user.progress;
  console.log(`Progress: ${progress}`);
  return res.status(200).send(`${progress} sucessfully sent`);
};

// Getting user's streak
export const getStreak = async (req, res) => {
  const id = req.user._id;
  // Check if id is valid
  if (!mongoose.isValidObjectId(id)) {
    return res.status(400).json({ message: "Invalid user ID" });
  }
  const user = await User.findOne({ _id: id });
  if (user === null) {
    return res.status(404).send(`User with id ${id} not found`);
  }
  const progress = user.streaks;
  console.log(`Progress: ${progress}`);
  return res.status(200).send(`${progress} sucessfully sent`);
};

// Getting a user's progress in a specific module
export const getUserModuleProgress = async (req, res) => {
  const userId = req.user._id; // Authenticated user's ID
  const moduleId = req.params.moduleId;

  // Validate moduleId
  if (!mongoose.isValidObjectId(moduleId)) {
    return res.status(400).json({ message: "Invalid module ID" });
  }
  try {
    const progressDocs = await UserProgress.find({
      user: userId,
      module: moduleId
    });
    if (!progressDocs.length) {
      return { moduleProgress: 0 }; // No progress yet
    }
    // Add up all level progresses for the module
    let totalProgress = 0;
    for (const doc of progressDocs) {
      totalProgress += doc.levelProgress.progress;
    }
    const moduleProgress = progressDocs.length ? total / progressDocs.length : 0;
    return res.status(200).json({ "User module progress": moduleProgress });
  } catch (error) {
    return res.status(500).json({ message: "Server error", error: error.message });
  }
};

// Getting all modules of a user
export const getModules = async (req, res) => {
  const userId = req.user._id;
  // Check if id is valid
  if (!mongoose.isValidObjectId(id)) {
    return res.status(400).json({ message: "Invalid user ID" });
  }
  const user = await User.findById(userId);
  // Checking is user is in database
  if (user === null) {
    return res.status(404).send(`User with id ${id} not found`);
  }
  const progressIds = user.progress;  // Obtaining user's progress IDs
  const progressModules = await UserProgress.find({ _id: { $in: progressIds } }).select("module"); // Retriving all of the modules of each progress id object
  const modules = progressModules.map(item => item.module); // Only obtaining the module objects as an array
  return res.status(200).json(modules);


}

// ---------- Journal Controllers ----------

// Creating a new journal entry
export const createJournalEntry = async (req, res) => {
  const userId = req.user._id;
  let { title, goals } = req.body || {};

  // Trim title
  title = title?.trim();

  // Check that both title and at least one goal are provided
  if (!title && (!goals || goals.length === 0)) {
    return res
      .status(400)
      .json({ message: "Please add a title and at least one goal to save your journal." });
  }
  if (!title) {
    return res.status(400).json({ message: "Please give your journal a title before saving." });
  }

  if (!goals || goals.length === 0) {
    return res.status(400).json({ message: "Add at least one goal to save your journal." });
  }

  try {
    // Check if user already has a journal with the same title
    const existing = await JournalEntry.findOne({
      user: userId,
      title: title
    });

    if (existing) {
      return res
        .status(400)
        .json({ message: "You already have a journal with this title. Try another one." });
    }

    const newEntry = new JournalEntry({
      user: userId,
      title,
      goals,
      month: new Date().getMonth() + 1, // 1-12
      date: new Date() // current date
    });
    const savedEntry = await newEntry.save();
    return res.status(201).json(savedEntry);
  } catch (error) {
    return res.status(500).json({ message: "Server error", error: error.message });
  }
};

// Getting a specific journal entry by ID
export const getJournalEntry = async (req, res) => {
  const userId = req.user._id;
  const journalId = req.params.id;

  // Validate journalId
  if (!mongoose.isValidObjectId(journalId)) {
    return res.status(400).json({ message: "Invalid journal ID" });
  }

  try {
    const journalEntry = await JournalEntry.findOne({
      _id: journalId,
      user: userId
    });
    if (!journalEntry) {
      return res.status(404).json({ message: "Journal entry not found" });
    }
    // Format date + month
    const formattedDate = formatDateAndMonth(journalEntry.date);

    return res.status(200).json({
      ...journalEntry.toObject(),
      date: formattedDate.date,
      month: formattedDate.month
    });
  } catch (error) {
    return res.status(500).json({ message: "Server error", error: error.message });
  }
};

// Getting all journal entries for a user
export const getAllJournalEntries = async (req, res) => {
  const userId = req.user._id;

  try {
    const user = await User.findById(userId, "_id firstName lastName username");
    const journalEntries = await JournalEntry.find({ user: userId });
    if (!journalEntries.length) {
      return res.status(200).json({ message: "No journal entries found" });
    }
    return res.status(200).json({ user, journalEntries });
  } catch (error) {
    return res.status(500).json({ message: "Server error", error: error.message });
  }
};

// Getting all journals of a user by month
export const getJournalsByMonth = async (req, res) => {
  const userId = req.user._id;
  // Check if id is valid
  if (!mongoose.isValidObjectId(id)) {
    return res.status(400).json({ message: "Invalid user ID" });
  }
  const user = await User.findById(userId);
  // Checking is user is in database
  if (user === null) {
    return res.status(404).send(`User with id ${id} not found`);
  }
  const year = parseInt(req.params.year);
  const month = parseInt(req.params.month) - 1; // JS Date months are 0-indexed so Jan is 0
  const startOfMonth = new Date(year, month, 1); // The format of the constructor is Date(year, month, day)
  const endOfMonth = new Date(year, month + 1, 1);
  const journals = await JournalEntry.find({
    "user": user,
    date: { $gte: startDate, $lt: endDate } // $gte is greater than or equal to startDate and $lt is less than the endDate
  });
  res.status(200).json(journals);
}

// Updating a journal entry
export const updateJournalEntry = async (req, res) => {
  const journalId = req.params.id;
  const updatedText = req.body;
  const updatedJournal = await JournalEntry.findByIdAndUpdate(
    journalId,
    updatedText,
    { new: true } // Ensures that the updated journal is returned
  );

  res.status(200).json(updatedJournal);
}